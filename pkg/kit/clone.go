/*
	Copyright Â© 2024 Macaroni OS Linux
	See AUTHORS and LICENSE for the license details and contributors.
*/

package kit

import (
	"fmt"
	"os"
	"path/filepath"
	"time"

	"github.com/macaroni-os/mark-devkit/pkg/logger"
	"github.com/macaroni-os/mark-devkit/pkg/specs"

	"github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/plumbing"
	"github.com/go-git/go-git/v5/plumbing/object"
	"github.com/go-git/go-git/v5/plumbing/storer"
	"github.com/go-git/go-git/v5/storage/memory"
	"github.com/macaroni-os/macaronictl/pkg/utils"
)

type CloneOptions struct {
	GitCloneOptions *git.CloneOptions
	Verbose         bool
	Summary         bool
	Results         []*specs.ReposcanKit

	// Commit data
	BoostrapCommitComment string
	SignatureName         string
	SignatureEmail        string
}

const (
	README = `# %s Kit

Macaroni OS Kit generated by mark-devkit.
`
)

func (co *CloneOptions) GetInitialCiComment() string {
	if co.BoostrapCommitComment == "" {
		return "Created branch by mark-devkit"
	}
	return co.BoostrapCommitComment
}

func (co *CloneOptions) GetSignatureName() string {
	if co.SignatureName == "" {
		return "MARK Devkit Bot"
	}
	return co.SignatureName
}

func (co *CloneOptions) GetSignatureEmail() string {
	if co.SignatureEmail == "" {
		return "mark-devkit-bot@macaronios.org"
	}

	return co.SignatureEmail
}

func CloneKits(k *specs.ReposcanAnalysis, targetdir string, o *CloneOptions) error {
	log := logger.GetDefaultLogger()
	var err error

	for _, kit := range k.Kits {
		kitdir := filepath.Join(targetdir, kit.Name)

		log.InfoC(log.Aurora.Bold(
			fmt.Sprintf(":factory:[%s] Syncing ...", kit.Name)),
		)
		err = Clone(kit, kitdir, o)
		if err != nil {
			return err
		}

	}

	return nil
}

func Clone(k *specs.ReposcanKit, targetdir string, o *CloneOptions) error {
	var r *git.Repository
	var err error
	log := logger.GetDefaultLogger()

	opts := *o.GitCloneOptions

	opts.URL = k.Url
	if k.Branch != "" {
		branchRefName := plumbing.NewBranchReferenceName(k.Branch)
		opts.ReferenceName = plumbing.ReferenceName(branchRefName)
	}

	if utils.Exists(targetdir) {
		// POST: The directory exists. I try to pull updates.

		pOpts := &git.PullOptions{
			SingleBranch:  opts.SingleBranch,
			Progress:      opts.Progress,
			Force:         true,
			RemoteName:    opts.RemoteName,
			ReferenceName: opts.ReferenceName,
			Depth:         opts.Depth,
		}

		r, err = git.PlainOpen(targetdir)
		if err != nil {
			return err
		}

		w, err := r.Worktree()
		if err != nil {
			return err
		}

		err = w.Pull(pOpts)
		if err == git.NoErrAlreadyUpToDate {
			log.Info(fmt.Sprintf(":check_mark_button:[%s] already up to date.",
				k.Name))
		} else if err != nil {
			return fmt.Errorf("error on pull repo %s for branch %s: %s",
				k.Name, k.Branch, err.Error())
		}
	} else {

		r, err = git.PlainClone(targetdir, false, &opts)
		if err != nil {
			return err
		}

	}

	if k.CommitSha1 != "" {
		w, err := r.Worktree()
		if err != nil {
			return err
		}

		chOpts := &git.CheckoutOptions{
			Hash:  plumbing.NewHash(k.CommitSha1),
			Force: true,
		}

		err = w.Checkout(chOpts)
		if err != nil {
			return fmt.Errorf("error on checkout repo %s for branch %s and hash %s: %s",
				k.Name, k.Branch, k.CommitSha1, err.Error())
		}
	}

	// Print the latest commit that was just pulled
	ref, err := r.Head()
	if err != nil {
		return err
	}
	log.Info(fmt.Sprintf(":right_arrow: [%s] @ %s",
		k.Name, ref.Hash()))
	if o.Verbose {
		commit, err := r.CommitObject(ref.Hash())
		if err != nil {
			return err
		}

		log.InfoC(fmt.Sprintf("%s", commit))
	}

	if o.Summary {
		res := *k
		res.CommitSha1 = fmt.Sprintf("%s", ref.Hash())
		o.Results = append(o.Results, &res)
	}

	return nil
}

func BranchExists(remoteUrl, branchName string) (bool, error) {
	repo, err := git.Clone(memory.NewStorage(), nil, &git.CloneOptions{
		URL:          remoteUrl,
		SingleBranch: false,
		NoCheckout:   true,
		Depth:        1,
		RemoteName:   "origin",
	})
	if err != nil {
		return false, err
	}

	// Retrieve the list of references
	refs, err := repo.References()
	if err != nil {
		return false, err
	}

	branchRef := "refs/remotes/origin/" + branchName
	present := false

	err = refs.ForEach(func(ref *plumbing.Reference) error {
		if ref.Name().String() == branchRef {
			present = true
			return storer.ErrStop
		}
		return nil
	})

	return present, err
}

func CloneAndCreateBranch(k *specs.ReposcanKit,
	targetdir string, o *CloneOptions) error {
	var r *git.Repository
	var err error
	log := logger.GetDefaultLogger()

	opts := *o.GitCloneOptions

	opts.URL = k.Url
	if k.Branch == "" {
		return fmt.Errorf("No branch specified for cloning and create")
	}

	if utils.Exists(targetdir) {
		err := os.RemoveAll(targetdir)
		if err != nil {
			return err
		}
	}

	log.InfoC(log.Aurora.Bold(
		fmt.Sprintf(":factory:[%s] Syncing ...", k.Name)),
	)
	r, err = git.PlainClone(targetdir, false, &opts)
	if err != nil {
		return err
	}

	log.InfoC(log.Aurora.Bold(
		fmt.Sprintf(":factory:[%s] Creating orphan branch %s...",
			k.Name, k.Branch)))

	branchRefName := plumbing.NewBranchReferenceName(k.Branch)
	err = r.Storer.SetReference(plumbing.NewSymbolicReference(
		plumbing.HEAD, branchRefName))
	if err != nil {
		return err
	}

	// Checkout in the new branch
	worktree, err := r.Worktree()
	if err != nil {
		return err
	}

	worktree.RemoveGlob("*")

	// Remove all files from the worktree, except .git
	// directory.
	err = cleanWorkingDirectory(targetdir)
	if err != nil {
		return err
	}

	// Add the initial README.md file
	newFile := filepath.Join(targetdir, "README.md")
	content := []byte(fmt.Sprintf(README, k.Name))
	err = os.WriteFile(newFile, content, 0644)
	if err != nil {
		return err
	}

	// Add README.md to the worktree
	commitHash, err := AddFilesAndCommit(worktree, []string{"README.md"},
		o.GetInitialCiComment(), o.GetSignatureName(),
		o.GetSignatureEmail())
	if err != nil {
		return err
	}

	// Set commit reference in the branch
	err = r.Storer.SetReference(plumbing.NewHashReference(branchRefName, commitHash))
	if err != nil {
		return err
	}

	log.Info(fmt.Sprintf(":right_arrow: [%s] @ %s",
		k.Name, commitHash))
	if o.Verbose {
		commit, err := r.CommitObject(commitHash)
		if err != nil {
			return err
		}

		log.InfoC(fmt.Sprintf("%s", commit))
	}

	if o.Summary {
		res := *k
		res.CommitSha1 = fmt.Sprintf("%s", commitHash)
		o.Results = append(o.Results, &res)
	}

	return nil
}

func AddFilesAndCommit(worktree *git.Worktree, files []string,
	commitMessage, signatureName, signatureEmail string) (plumbing.Hash, error) {

	for _, file := range files {
		_, err := worktree.Add(file)
		if err != nil {
			return plumbing.ZeroHash, fmt.Errorf("error on add file %s to worktree: %s",
				file, err.Error())
		}
	}

	// Creating initial commit
	return worktree.Commit(commitMessage, &git.CommitOptions{
		Author: &object.Signature{
			Name:  signatureName,
			Email: signatureEmail,
			When:  time.Now(),
		},
	})
}

func cleanWorkingDirectory(path string) error {
	entries, err := os.ReadDir(path)
	if err != nil {
		return err
	}

	for _, entry := range entries {
		// Exclude .git directory
		if entry.IsDir() && entry.Name() == ".git" {
			continue
		}

		entryPath := filepath.Join(path, entry.Name())
		err = os.RemoveAll(entryPath)
		if err != nil {
			return err
		}
	}

	return nil
}
